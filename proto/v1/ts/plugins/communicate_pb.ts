// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file plugins/communicate.proto (package v1.plugins.communicate, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message as Message$1, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum v1.plugins.communicate.Method
 */
export enum Method {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Factory
   *
   * @generated from enum value: CREATE = 1;
   */
  CREATE = 1,

  /**
   * Runtime
   *
   * @generated from enum value: SYNC = 10;
   */
  SYNC = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(Method)
proto3.util.setEnumType(Method, "v1.plugins.communicate.Method", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "CREATE" },
  { no: 10, name: "SYNC" },
]);

/**
 * @generated from message v1.plugins.communicate.Channel
 */
export class Channel extends Message$1<Channel> {
  /**
   * @generated from field: v1.plugins.communicate.Method method = 1;
   */
  method = Method.UNKNOWN;

  constructor(data?: PartialMessage<Channel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.Channel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "method", kind: "enum", T: proto3.getEnumType(Method) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Channel {
    return new Channel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Channel {
    return new Channel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Channel {
    return new Channel().fromJsonString(jsonString, options);
  }

  static equals(a: Channel | PlainMessage<Channel> | undefined, b: Channel | PlainMessage<Channel> | undefined): boolean {
    return proto3.util.equals(Channel, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.Message
 */
export class Message extends Message$1<Message> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * @generated from field: string description = 3;
   */
  description = "";

  constructor(data?: PartialMessage<Message>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.Message";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Message {
    return new Message().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Message {
    return new Message().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Message {
    return new Message().fromJsonString(jsonString, options);
  }

  static equals(a: Message | PlainMessage<Message> | undefined, b: Message | PlainMessage<Message> | undefined): boolean {
    return proto3.util.equals(Message, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.Display
 */
export class Display extends Message$1<Display> {
  /**
   * @generated from field: map<string, string> data = 1;
   */
  data: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Display>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.Display";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Display {
    return new Display().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Display {
    return new Display().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Display {
    return new Display().fromJsonString(jsonString, options);
  }

  static equals(a: Display | PlainMessage<Display> | undefined, b: Display | PlainMessage<Display> | undefined): boolean {
    return proto3.util.equals(Display, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.Confirm
 */
export class Confirm extends Message$1<Confirm> {
  /**
   * @generated from field: bool default = 1;
   */
  default = false;

  constructor(data?: PartialMessage<Confirm>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.Confirm";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "default", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Confirm {
    return new Confirm().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Confirm {
    return new Confirm().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Confirm {
    return new Confirm().fromJsonString(jsonString, options);
  }

  static equals(a: Confirm | PlainMessage<Confirm> | undefined, b: Confirm | PlainMessage<Confirm> | undefined): boolean {
    return proto3.util.equals(Confirm, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.ConfirmAnswer
 */
export class ConfirmAnswer extends Message$1<ConfirmAnswer> {
  /**
   * @generated from field: bool confirmed = 1;
   */
  confirmed = false;

  constructor(data?: PartialMessage<ConfirmAnswer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.ConfirmAnswer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "confirmed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfirmAnswer {
    return new ConfirmAnswer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfirmAnswer {
    return new ConfirmAnswer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfirmAnswer {
    return new ConfirmAnswer().fromJsonString(jsonString, options);
  }

  static equals(a: ConfirmAnswer | PlainMessage<ConfirmAnswer> | undefined, b: ConfirmAnswer | PlainMessage<ConfirmAnswer> | undefined): boolean {
    return proto3.util.equals(ConfirmAnswer, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.Input
 */
export class Input extends Message$1<Input> {
  /**
   * @generated from oneof v1.plugins.communicate.Input.default
   */
  default: {
    /**
     * @generated from field: string string_default = 1;
     */
    value: string;
    case: "stringDefault";
  } | {
    /**
     * @generated from field: int32 int_default = 2;
     */
    value: number;
    case: "intDefault";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Input>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.Input";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "string_default", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "default" },
    { no: 2, name: "int_default", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "default" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Input {
    return new Input().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Input {
    return new Input().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Input {
    return new Input().fromJsonString(jsonString, options);
  }

  static equals(a: Input | PlainMessage<Input> | undefined, b: Input | PlainMessage<Input> | undefined): boolean {
    return proto3.util.equals(Input, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.InputAnswer
 */
export class InputAnswer extends Message$1<InputAnswer> {
  /**
   * @generated from oneof v1.plugins.communicate.InputAnswer.answer
   */
  answer: {
    /**
     * @generated from field: string string_value = 1;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * @generated from field: int32 int_value = 2;
     */
    value: number;
    case: "intValue";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<InputAnswer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.InputAnswer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "string_value", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "answer" },
    { no: 2, name: "int_value", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "answer" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InputAnswer {
    return new InputAnswer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InputAnswer {
    return new InputAnswer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InputAnswer {
    return new InputAnswer().fromJsonString(jsonString, options);
  }

  static equals(a: InputAnswer | PlainMessage<InputAnswer> | undefined, b: InputAnswer | PlainMessage<InputAnswer> | undefined): boolean {
    return proto3.util.equals(InputAnswer, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.Choice
 */
export class Choice extends Message$1<Choice> {
  /**
   * @generated from field: repeated v1.plugins.communicate.Message options = 1;
   */
  options: Message[] = [];

  constructor(data?: PartialMessage<Choice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.Choice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "options", kind: "message", T: Message, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Choice {
    return new Choice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Choice {
    return new Choice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Choice {
    return new Choice().fromJsonString(jsonString, options);
  }

  static equals(a: Choice | PlainMessage<Choice> | undefined, b: Choice | PlainMessage<Choice> | undefined): boolean {
    return proto3.util.equals(Choice, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.ChoiceAnswer
 */
export class ChoiceAnswer extends Message$1<ChoiceAnswer> {
  /**
   * @generated from field: string option = 1;
   */
  option = "";

  constructor(data?: PartialMessage<ChoiceAnswer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.ChoiceAnswer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "option", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChoiceAnswer {
    return new ChoiceAnswer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChoiceAnswer {
    return new ChoiceAnswer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChoiceAnswer {
    return new ChoiceAnswer().fromJsonString(jsonString, options);
  }

  static equals(a: ChoiceAnswer | PlainMessage<ChoiceAnswer> | undefined, b: ChoiceAnswer | PlainMessage<ChoiceAnswer> | undefined): boolean {
    return proto3.util.equals(ChoiceAnswer, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.Selection
 */
export class Selection extends Message$1<Selection> {
  /**
   * @generated from field: repeated v1.plugins.communicate.Message options = 1;
   */
  options: Message[] = [];

  constructor(data?: PartialMessage<Selection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.Selection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "options", kind: "message", T: Message, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Selection {
    return new Selection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Selection {
    return new Selection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Selection {
    return new Selection().fromJsonString(jsonString, options);
  }

  static equals(a: Selection | PlainMessage<Selection> | undefined, b: Selection | PlainMessage<Selection> | undefined): boolean {
    return proto3.util.equals(Selection, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.SelectionAnswer
 */
export class SelectionAnswer extends Message$1<SelectionAnswer> {
  /**
   * @generated from field: repeated string selected = 1;
   */
  selected: string[] = [];

  constructor(data?: PartialMessage<SelectionAnswer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.SelectionAnswer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "selected", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SelectionAnswer {
    return new SelectionAnswer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SelectionAnswer {
    return new SelectionAnswer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SelectionAnswer {
    return new SelectionAnswer().fromJsonString(jsonString, options);
  }

  static equals(a: SelectionAnswer | PlainMessage<SelectionAnswer> | undefined, b: SelectionAnswer | PlainMessage<SelectionAnswer> | undefined): boolean {
    return proto3.util.equals(SelectionAnswer, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.Question
 */
export class Question extends Message$1<Question> {
  /**
   * @generated from field: v1.plugins.communicate.Method method = 1;
   */
  method = Method.UNKNOWN;

  /**
   * @generated from field: int32 round = 2;
   */
  round = 0;

  /**
   * @generated from field: v1.plugins.communicate.Message message = 3;
   */
  message?: Message;

  /**
   * @generated from oneof v1.plugins.communicate.Question.value
   */
  value: {
    /**
     * @generated from field: v1.plugins.communicate.Display display = 4;
     */
    value: Display;
    case: "display";
  } | {
    /**
     * @generated from field: v1.plugins.communicate.Confirm confirm = 5;
     */
    value: Confirm;
    case: "confirm";
  } | {
    /**
     * @generated from field: v1.plugins.communicate.Input input = 6;
     */
    value: Input;
    case: "input";
  } | {
    /**
     * @generated from field: v1.plugins.communicate.Choice choice = 7;
     */
    value: Choice;
    case: "choice";
  } | {
    /**
     * @generated from field: v1.plugins.communicate.Selection selection = 8;
     */
    value: Selection;
    case: "selection";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Question>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.Question";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "method", kind: "enum", T: proto3.getEnumType(Method) },
    { no: 2, name: "round", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "message", kind: "message", T: Message },
    { no: 4, name: "display", kind: "message", T: Display, oneof: "value" },
    { no: 5, name: "confirm", kind: "message", T: Confirm, oneof: "value" },
    { no: 6, name: "input", kind: "message", T: Input, oneof: "value" },
    { no: 7, name: "choice", kind: "message", T: Choice, oneof: "value" },
    { no: 8, name: "selection", kind: "message", T: Selection, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Question {
    return new Question().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Question {
    return new Question().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Question {
    return new Question().fromJsonString(jsonString, options);
  }

  static equals(a: Question | PlainMessage<Question> | undefined, b: Question | PlainMessage<Question> | undefined): boolean {
    return proto3.util.equals(Question, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.Answer
 */
export class Answer extends Message$1<Answer> {
  /**
   * @generated from field: bool done = 1;
   */
  done = false;

  /**
   * @generated from field: v1.plugins.communicate.Method method = 2;
   */
  method = Method.UNKNOWN;

  /**
   * @generated from field: int32 round = 3;
   */
  round = 0;

  /**
   * @generated from field: string error = 4;
   */
  error = "";

  /**
   * @generated from oneof v1.plugins.communicate.Answer.value
   */
  value: {
    /**
     * @generated from field: v1.plugins.communicate.ConfirmAnswer confirm = 5;
     */
    value: ConfirmAnswer;
    case: "confirm";
  } | {
    /**
     * @generated from field: v1.plugins.communicate.InputAnswer input = 6;
     */
    value: InputAnswer;
    case: "input";
  } | {
    /**
     * @generated from field: v1.plugins.communicate.ChoiceAnswer choice = 7;
     */
    value: ChoiceAnswer;
    case: "choice";
  } | {
    /**
     * @generated from field: v1.plugins.communicate.SelectionAnswer selection = 8;
     */
    value: SelectionAnswer;
    case: "selection";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Answer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.Answer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "done", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "method", kind: "enum", T: proto3.getEnumType(Method) },
    { no: 3, name: "round", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "confirm", kind: "message", T: ConfirmAnswer, oneof: "value" },
    { no: 6, name: "input", kind: "message", T: InputAnswer, oneof: "value" },
    { no: 7, name: "choice", kind: "message", T: ChoiceAnswer, oneof: "value" },
    { no: 8, name: "selection", kind: "message", T: SelectionAnswer, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Answer {
    return new Answer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Answer {
    return new Answer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Answer {
    return new Answer().fromJsonString(jsonString, options);
  }

  static equals(a: Answer | PlainMessage<Answer> | undefined, b: Answer | PlainMessage<Answer> | undefined): boolean {
    return proto3.util.equals(Answer, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.Engage
 */
export class Engage extends Message$1<Engage> {
  /**
   * @generated from field: v1.plugins.communicate.Method method = 1;
   */
  method = Method.UNKNOWN;

  /**
   * @generated from field: v1.plugins.communicate.Answer answer = 2;
   */
  answer?: Answer;

  constructor(data?: PartialMessage<Engage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.Engage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "method", kind: "enum", T: proto3.getEnumType(Method) },
    { no: 2, name: "answer", kind: "message", T: Answer },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Engage {
    return new Engage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Engage {
    return new Engage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Engage {
    return new Engage().fromJsonString(jsonString, options);
  }

  static equals(a: Engage | PlainMessage<Engage> | undefined, b: Engage | PlainMessage<Engage> | undefined): boolean {
    return proto3.util.equals(Engage, a, b);
  }
}

/**
 * @generated from message v1.plugins.communicate.InformationRequest
 */
export class InformationRequest extends Message$1<InformationRequest> {
  /**
   * @generated from field: v1.plugins.communicate.Method method = 1;
   */
  method = Method.UNKNOWN;

  /**
   * @generated from field: bool done = 2;
   */
  done = false;

  /**
   * @generated from field: v1.plugins.communicate.Question question = 3;
   */
  question?: Question;

  constructor(data?: PartialMessage<InformationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.plugins.communicate.InformationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "method", kind: "enum", T: proto3.getEnumType(Method) },
    { no: 2, name: "done", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "question", kind: "message", T: Question },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InformationRequest {
    return new InformationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InformationRequest {
    return new InformationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InformationRequest {
    return new InformationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: InformationRequest | PlainMessage<InformationRequest> | undefined, b: InformationRequest | PlainMessage<InformationRequest> | undefined): boolean {
    return proto3.util.equals(InformationRequest, a, b);
  }
}

