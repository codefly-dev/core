// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file services/runtime/runtime.proto (package v1.services.runtime, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Version } from "../init_pb.js";
import { Channel } from "../../plugins/communicate_pb.js";
import { Endpoint, EndpointGroup } from "../../base/api_pb.js";
import { Tracker } from "./tracker_pb.js";

/**
 * @generated from message v1.services.runtime.InitStatus
 */
export class InitStatus extends Message<InitStatus> {
  /**
   * @generated from field: v1.services.runtime.InitStatus.State state = 1;
   */
  state = InitStatus_State.UNKNOWN;

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<InitStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.services.runtime.InitStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(InitStatus_State) },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InitStatus {
    return new InitStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InitStatus {
    return new InitStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InitStatus {
    return new InitStatus().fromJsonString(jsonString, options);
  }

  static equals(a: InitStatus | PlainMessage<InitStatus> | undefined, b: InitStatus | PlainMessage<InitStatus> | undefined): boolean {
    return proto3.util.equals(InitStatus, a, b);
  }
}

/**
 * @generated from enum v1.services.runtime.InitStatus.State
 */
export enum InitStatus_State {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: READY = 1;
   */
  READY = 1,

  /**
   * @generated from enum value: ERROR = 2;
   */
  ERROR = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(InitStatus_State)
proto3.util.setEnumType(InitStatus_State, "v1.services.runtime.InitStatus.State", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "READY" },
  { no: 2, name: "ERROR" },
]);

/**
 * @generated from message v1.services.runtime.InitResponse
 */
export class InitResponse extends Message<InitResponse> {
  /**
   * @generated from field: v1.services.Version version = 1;
   */
  version?: Version;

  /**
   * The communication channels of the service
   *
   * @generated from field: repeated v1.plugins.communicate.Channel channels = 2;
   */
  channels: Channel[] = [];

  /**
   * Endpoints exposed by the service
   *
   * @generated from field: repeated v1.base.Endpoint endpoints = 3;
   */
  endpoints: Endpoint[] = [];

  /**
   * @generated from field: v1.services.runtime.InitStatus status = 4;
   */
  status?: InitStatus;

  constructor(data?: PartialMessage<InitResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.services.runtime.InitResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "message", T: Version },
    { no: 2, name: "channels", kind: "message", T: Channel, repeated: true },
    { no: 3, name: "endpoints", kind: "message", T: Endpoint, repeated: true },
    { no: 4, name: "status", kind: "message", T: InitStatus },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InitResponse {
    return new InitResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InitResponse {
    return new InitResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InitResponse {
    return new InitResponse().fromJsonString(jsonString, options);
  }

  static equals(a: InitResponse | PlainMessage<InitResponse> | undefined, b: InitResponse | PlainMessage<InitResponse> | undefined): boolean {
    return proto3.util.equals(InitResponse, a, b);
  }
}

/**
 * @generated from message v1.services.runtime.ConfigureStatus
 */
export class ConfigureStatus extends Message<ConfigureStatus> {
  /**
   * @generated from field: v1.services.runtime.ConfigureStatus.State state = 1;
   */
  state = ConfigureStatus_State.UNKNOWN;

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<ConfigureStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.services.runtime.ConfigureStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(ConfigureStatus_State) },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigureStatus {
    return new ConfigureStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigureStatus {
    return new ConfigureStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigureStatus {
    return new ConfigureStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ConfigureStatus | PlainMessage<ConfigureStatus> | undefined, b: ConfigureStatus | PlainMessage<ConfigureStatus> | undefined): boolean {
    return proto3.util.equals(ConfigureStatus, a, b);
  }
}

/**
 * @generated from enum v1.services.runtime.ConfigureStatus.State
 */
export enum ConfigureStatus_State {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: READY = 1;
   */
  READY = 1,

  /**
   * @generated from enum value: ERROR = 2;
   */
  ERROR = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConfigureStatus_State)
proto3.util.setEnumType(ConfigureStatus_State, "v1.services.runtime.ConfigureStatus.State", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "READY" },
  { no: 2, name: "ERROR" },
]);

/**
 * @generated from message v1.services.runtime.ConfigureRequest
 */
export class ConfigureRequest extends Message<ConfigureRequest> {
  constructor(data?: PartialMessage<ConfigureRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.services.runtime.ConfigureRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigureRequest {
    return new ConfigureRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigureRequest {
    return new ConfigureRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigureRequest {
    return new ConfigureRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ConfigureRequest | PlainMessage<ConfigureRequest> | undefined, b: ConfigureRequest | PlainMessage<ConfigureRequest> | undefined): boolean {
    return proto3.util.equals(ConfigureRequest, a, b);
  }
}

/**
 * @generated from message v1.services.runtime.ConfigureResponse
 */
export class ConfigureResponse extends Message<ConfigureResponse> {
  /**
   * @generated from field: v1.services.runtime.ConfigureStatus status = 2;
   */
  status?: ConfigureStatus;

  /**
   * @generated from field: repeated v1.services.runtime.NetworkMapping network_mappings = 3;
   */
  networkMappings: NetworkMapping[] = [];

  constructor(data?: PartialMessage<ConfigureResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.services.runtime.ConfigureResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "status", kind: "message", T: ConfigureStatus },
    { no: 3, name: "network_mappings", kind: "message", T: NetworkMapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigureResponse {
    return new ConfigureResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigureResponse {
    return new ConfigureResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigureResponse {
    return new ConfigureResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ConfigureResponse | PlainMessage<ConfigureResponse> | undefined, b: ConfigureResponse | PlainMessage<ConfigureResponse> | undefined): boolean {
    return proto3.util.equals(ConfigureResponse, a, b);
  }
}

/**
 * @generated from message v1.services.runtime.NetworkMapping
 */
export class NetworkMapping extends Message<NetworkMapping> {
  /**
   * Application name
   *
   * @generated from field: string application = 1;
   */
  application = "";

  /**
   * Service name
   *
   * @generated from field: string service = 2;
   */
  service = "";

  /**
   * @generated from field: v1.base.Endpoint endpoint = 3;
   */
  endpoint?: Endpoint;

  /**
   * List of addresses to map to
   *
   * @generated from field: repeated string addresses = 4;
   */
  addresses: string[] = [];

  constructor(data?: PartialMessage<NetworkMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.services.runtime.NetworkMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "application", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "endpoint", kind: "message", T: Endpoint },
    { no: 4, name: "addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkMapping {
    return new NetworkMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkMapping {
    return new NetworkMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkMapping {
    return new NetworkMapping().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkMapping | PlainMessage<NetworkMapping> | undefined, b: NetworkMapping | PlainMessage<NetworkMapping> | undefined): boolean {
    return proto3.util.equals(NetworkMapping, a, b);
  }
}

/**
 * @generated from message v1.services.runtime.StartRequest
 */
export class StartRequest extends Message<StartRequest> {
  /**
   * @generated from field: repeated v1.services.runtime.NetworkMapping network_mappings = 1;
   */
  networkMappings: NetworkMapping[] = [];

  /**
   * @generated from field: v1.base.EndpointGroup dependency_endpoint_group = 2;
   */
  dependencyEndpointGroup?: EndpointGroup;

  constructor(data?: PartialMessage<StartRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.services.runtime.StartRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "network_mappings", kind: "message", T: NetworkMapping, repeated: true },
    { no: 2, name: "dependency_endpoint_group", kind: "message", T: EndpointGroup },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartRequest {
    return new StartRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartRequest {
    return new StartRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartRequest {
    return new StartRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartRequest | PlainMessage<StartRequest> | undefined, b: StartRequest | PlainMessage<StartRequest> | undefined): boolean {
    return proto3.util.equals(StartRequest, a, b);
  }
}

/**
 * @generated from message v1.services.runtime.StartStatus
 */
export class StartStatus extends Message<StartStatus> {
  /**
   * @generated from field: v1.services.runtime.StartStatus.State state = 1;
   */
  state = StartStatus_State.UNKNOWN;

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<StartStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.services.runtime.StartStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(StartStatus_State) },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartStatus {
    return new StartStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartStatus {
    return new StartStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartStatus {
    return new StartStatus().fromJsonString(jsonString, options);
  }

  static equals(a: StartStatus | PlainMessage<StartStatus> | undefined, b: StartStatus | PlainMessage<StartStatus> | undefined): boolean {
    return proto3.util.equals(StartStatus, a, b);
  }
}

/**
 * @generated from enum v1.services.runtime.StartStatus.State
 */
export enum StartStatus_State {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: STARTED = 1;
   */
  STARTED = 1,

  /**
   * @generated from enum value: ERROR = 2;
   */
  ERROR = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(StartStatus_State)
proto3.util.setEnumType(StartStatus_State, "v1.services.runtime.StartStatus.State", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "STARTED" },
  { no: 2, name: "ERROR" },
]);

/**
 * @generated from message v1.services.runtime.StartResponse
 */
export class StartResponse extends Message<StartResponse> {
  /**
   * @generated from field: v1.services.runtime.StartStatus status = 1;
   */
  status?: StartStatus;

  /**
   * @generated from field: repeated v1.services.runtime.Tracker trackers = 2;
   */
  trackers: Tracker[] = [];

  constructor(data?: PartialMessage<StartResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.services.runtime.StartResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "message", T: StartStatus },
    { no: 2, name: "trackers", kind: "message", T: Tracker, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartResponse {
    return new StartResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartResponse {
    return new StartResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartResponse {
    return new StartResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StartResponse | PlainMessage<StartResponse> | undefined, b: StartResponse | PlainMessage<StartResponse> | undefined): boolean {
    return proto3.util.equals(StartResponse, a, b);
  }
}

/**
 * @generated from message v1.services.runtime.InformationRequest
 */
export class InformationRequest extends Message<InformationRequest> {
  constructor(data?: PartialMessage<InformationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.services.runtime.InformationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InformationRequest {
    return new InformationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InformationRequest {
    return new InformationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InformationRequest {
    return new InformationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: InformationRequest | PlainMessage<InformationRequest> | undefined, b: InformationRequest | PlainMessage<InformationRequest> | undefined): boolean {
    return proto3.util.equals(InformationRequest, a, b);
  }
}

/**
 * @generated from message v1.services.runtime.InformationResponse
 */
export class InformationResponse extends Message<InformationResponse> {
  /**
   * @generated from field: v1.services.runtime.InformationResponse.Status status = 1;
   */
  status = InformationResponse_Status.UNKNOWN;

  constructor(data?: PartialMessage<InformationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.services.runtime.InformationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(InformationResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InformationResponse {
    return new InformationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InformationResponse {
    return new InformationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InformationResponse {
    return new InformationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: InformationResponse | PlainMessage<InformationResponse> | undefined, b: InformationResponse | PlainMessage<InformationResponse> | undefined): boolean {
    return proto3.util.equals(InformationResponse, a, b);
  }
}

/**
 * @generated from enum v1.services.runtime.InformationResponse.Status
 */
export enum InformationResponse_Status {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: INIT = 1;
   */
  INIT = 1,

  /**
   * @generated from enum value: STARTED = 2;
   */
  STARTED = 2,

  /**
   * @generated from enum value: RESTART_WANTED = 3;
   */
  RESTART_WANTED = 3,

  /**
   * @generated from enum value: SYNC_WANTED = 4;
   */
  SYNC_WANTED = 4,

  /**
   * @generated from enum value: STOPPED = 5;
   */
  STOPPED = 5,

  /**
   * @generated from enum value: ERROR = 6;
   */
  ERROR = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(InformationResponse_Status)
proto3.util.setEnumType(InformationResponse_Status, "v1.services.runtime.InformationResponse.Status", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "INIT" },
  { no: 2, name: "STARTED" },
  { no: 3, name: "RESTART_WANTED" },
  { no: 4, name: "SYNC_WANTED" },
  { no: 5, name: "STOPPED" },
  { no: 6, name: "ERROR" },
]);

/**
 * @generated from message v1.services.runtime.StopRequest
 */
export class StopRequest extends Message<StopRequest> {
  /**
   * Persist the service instance
   *
   * @generated from field: bool persist = 1;
   */
  persist = false;

  constructor(data?: PartialMessage<StopRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.services.runtime.StopRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "persist", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StopRequest {
    return new StopRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StopRequest {
    return new StopRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StopRequest {
    return new StopRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StopRequest | PlainMessage<StopRequest> | undefined, b: StopRequest | PlainMessage<StopRequest> | undefined): boolean {
    return proto3.util.equals(StopRequest, a, b);
  }
}

/**
 * @generated from message v1.services.runtime.StopResponse
 */
export class StopResponse extends Message<StopResponse> {
  constructor(data?: PartialMessage<StopResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.services.runtime.StopResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StopResponse {
    return new StopResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StopResponse {
    return new StopResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StopResponse {
    return new StopResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StopResponse | PlainMessage<StopResponse> | undefined, b: StopResponse | PlainMessage<StopResponse> | undefined): boolean {
    return proto3.util.equals(StopResponse, a, b);
  }
}

